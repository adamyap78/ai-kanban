<script>
// Chat functionality
let chatMessages = [];

function handleChatKeyDown(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        // Only handle enter key if the chat modal is open
        const chatModal = document.getElementById('chatModal');
        if (chatModal && chatModal.open) {
            event.preventDefault();
            sendChatMessage();
        }
    }
}

function adjustTextareaHeight(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 128) + 'px';
    
    // Enable/disable send button based on content
    const sendButton = document.getElementById('sendButton');
    const hasContent = textarea.value.trim().length > 0;
    sendButton.disabled = !hasContent;
}


function showThinkingIndicator() {
    const thinkingElement = document.getElementById('chatThinking');
    thinkingElement.classList.remove('hidden');
    
    // Scroll to bottom to show thinking indicator
    const messagesContainer = document.getElementById('chatMessages');
    setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight + 100;
    }, 50);
}

function hideThinkingIndicator() {
    const thinkingElement = document.getElementById('chatThinking');
    thinkingElement.classList.add('hidden');
}

function applyBasicFormatting(text) {
    // Split into lines for processing
    const lines = text.split('\n');
    const formattedLines = lines.map(line => {
        // Handle headings
        if (line.startsWith('# ')) {
            return `<h1 class="text-lg font-bold mt-3 mb-2 first:mt-0">${line.substring(2)}</h1>`;
        } else if (line.startsWith('## ')) {
            return `<h2 class="text-base font-bold mt-3 mb-2 first:mt-0">${line.substring(3)}</h2>`;
        } else if (line.startsWith('### ')) {
            return `<h3 class="text-sm font-bold mt-2 mb-1 first:mt-0">${line.substring(4)}</h3>`;
        }
        
        // Handle lists (bullet points and numbered)
        else if (line.match(/^[\s]*[-*]\s+/)) {
            const indent = line.match(/^(\s*)/)[1].length;
            const content = line.replace(/^[\s]*[-*]\s+/, '');
            const marginLeft = indent > 0 ? `ml-${Math.min(indent, 8)}` : 'ml-2';
            return `<div class="flex items-start ${marginLeft} mb-1"><span class="mr-2 mt-1 w-1 h-1 bg-gray-600 rounded-full flex-shrink-0"></span><span>${content}</span></div>`;
        } else if (line.match(/^[\s]*\d+\.\s+/)) {
            const indent = line.match(/^(\s*)/)[1].length;
            const content = line.replace(/^[\s]*\d+\.\s+/, '');
            const number = line.match(/\d+/)[0];
            const marginLeft = indent > 0 ? `ml-${Math.min(indent, 8)}` : 'ml-2';
            return `<div class="flex items-start ${marginLeft} mb-1"><span class="mr-2 text-sm font-medium text-gray-600 flex-shrink-0">${number}.</span><span>${content}</span></div>`;
        }
        
        // Regular line - return as is
        return line;
    });
    
    // Join with <br> for line breaks, but don't add <br> after block elements
    let result = '';
    for (let i = 0; i < formattedLines.length; i++) {
        const line = formattedLines[i];
        result += line;
        
        // Add <br> only if:
        // 1. Not the last line
        // 2. Current line is not a block element (heading, list item)
        // 3. Next line is not a block element
        if (i < formattedLines.length - 1) {
            const isCurrentBlock = line.includes('<h1') || line.includes('<h2') || line.includes('<h3') || line.includes('<div class="flex');
            const isNextBlock = formattedLines[i + 1].includes('<h1') || formattedLines[i + 1].includes('<h2') || formattedLines[i + 1].includes('<h3') || formattedLines[i + 1].includes('<div class="flex');
            
            if (!isCurrentBlock && !isNextBlock && line.trim() !== '') {
                result += '<br>';
            }
        }
    }
    
    return result;
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Clear input and reset height
    input.value = '';
    input.style.height = 'auto';
    
    // Update UI state
    const sendButton = document.getElementById('sendButton');
    sendButton.disabled = true;
    
    // Add user message to UI
    addMessageToUI('user', message);
    
    // Add user message to conversation
    chatMessages.push({ role: 'user', content: message });
    
    // Show thinking indicator
    showThinkingIndicator();
    
    // Try streaming first, fallback to regular POST if it fails
    sendChatMessageStreaming()
        .catch(error => {
            console.warn('Streaming failed, falling back to regular request:', error);
            sendChatMessageRegular();
        })
        .finally(() => {
            // Reset UI state
            hideThinkingIndicator();
            sendButton.disabled = false;
        });
}

function sendChatMessageStreaming() {
    return new Promise((resolve, reject) => {
        // Create streaming AI message container
        const streamingMessageId = 'streaming-message-' + Date.now();
        addStreamingMessageToUI(streamingMessageId);
        
        // Build SSE URL with messages as query parameter
        const messagesParam = encodeURIComponent(JSON.stringify(chatMessages));
        const eventSource = new EventSource(`/api/chat/stream?messages=${messagesParam}`);
        
        let streamedContent = '';
        let hasError = false;
        
        eventSource.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                
                if (data.type === 'content') {
                    streamedContent += data.content;
                    updateStreamingMessage(streamingMessageId, streamedContent);
                } else if (data.type === 'complete') {
                    // Finalize the streaming message (remove cursor and render markdown)
                    finalizeStreamingMessage(streamingMessageId, streamedContent);
                    
                    // Add completed message to conversation history
                    chatMessages.push({ role: 'assistant', content: streamedContent });
                    
                    eventSource.close();
                    resolve();
                } else if (data.type === 'error') {
                    hasError = true;
                    
                    // Remove streaming message and show error
                    removeStreamingMessage(streamingMessageId);
                    addMessageToUI('assistant', 'Sorry, I encountered an error. Please try again.');
                    
                    eventSource.close();
                    reject(new Error(data.error || 'Streaming error'));
                }
            } catch (parseError) {
                console.error('Error parsing SSE data:', parseError);
            }
        };
        
        eventSource.onerror = function(event) {
            console.error('SSE connection error:', event);
            
            if (!hasError) {
                // Remove streaming message
                removeStreamingMessage(streamingMessageId);
            }
            
            eventSource.close();
            reject(new Error('SSE connection failed'));
        };
        
        // Set timeout for streaming requests
        setTimeout(() => {
            if (eventSource.readyState !== EventSource.CLOSED) {
                eventSource.close();
                if (!hasError) {
                    removeStreamingMessage(streamingMessageId);
                }
                reject(new Error('Streaming timeout'));
            }
        }, 30000); // 30 second timeout
    });
}

function sendChatMessageRegular() {
    // Send to API using original method
    fetch('/api/chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ messages: chatMessages })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.choices && data.choices[0] && data.choices[0].message) {
            const assistantMessage = data.choices[0].message;
            
            // Add AI response to conversation
            chatMessages.push(assistantMessage);
            
            // Add AI response to UI
            addMessageToUI('assistant', assistantMessage.content);
        } else {
            throw new Error('Invalid response format');
        }
    })
    .catch(error => {
        console.error('Chat error:', error);
        
        // Show error message
        addMessageToUI('assistant', 'Sorry, I encountered an error. Please try again.');
    });
}

function addMessageToUI(role, content) {
    const messagesContainer = document.getElementById('chatMessages');
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat ${role === 'user' ? 'chat-end' : 'chat-start'}`;
    
    // Create avatar for assistant messages
    if (role === 'assistant') {
        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'chat-image avatar';
        avatarDiv.innerHTML = `
            <div class="w-8 h-8 rounded-full">
                <div class="bg-primary text-primary-content rounded-full w-8 h-8 flex items-center justify-center">
                    <span class="text-xs">AI</span>
                </div>
            </div>
        `;
        messageDiv.appendChild(avatarDiv);
        
        // Add header with timestamp
        const headerDiv = document.createElement('div');
        headerDiv.className = 'chat-header text-xs opacity-50 mb-1';
        headerDiv.innerHTML = `AI Assistant <time class="text-xs opacity-50 ml-2">${new Date().toLocaleTimeString()}</time>`;
        messageDiv.appendChild(headerDiv);
    } else {
        // Add header for user messages
        const headerDiv = document.createElement('div');
        headerDiv.className = 'chat-header text-xs opacity-50 mb-1';
        headerDiv.innerHTML = `You <time class="text-xs opacity-50 ml-2">${new Date().toLocaleTimeString()}</time>`;
        messageDiv.appendChild(headerDiv);
    }
    
    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = `chat-bubble ${role === 'user' ? 'chat-bubble-secondary max-w-xs' : 'bg-gray-100 text-gray-800 max-w-2xl'}`;
    
    if (role === 'assistant' && typeof marked !== 'undefined') {
        // Render markdown for AI messages
        bubbleDiv.innerHTML = marked.parse(content);
    } else {
        // Plain text for user messages (security) or fallback
        bubbleDiv.textContent = content;
    }
    
    messageDiv.appendChild(bubbleDiv);
    messagesContainer.appendChild(messageDiv);
    
    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function addStreamingMessageToUI(messageId) {
    const messagesContainer = document.getElementById('chatMessages');
    
    const messageDiv = document.createElement('div');
    messageDiv.id = messageId;
    messageDiv.className = 'chat chat-start';
    
    // Create avatar
    const avatarDiv = document.createElement('div');
    avatarDiv.className = 'chat-image avatar';
    avatarDiv.innerHTML = `
        <div class="w-8 h-8 rounded-full">
            <div class="bg-primary text-primary-content rounded-full w-8 h-8 flex items-center justify-center">
                <span class="text-xs">AI</span>
            </div>
        </div>
    `;
    messageDiv.appendChild(avatarDiv);
    
    // Add header
    const headerDiv = document.createElement('div');
    headerDiv.className = 'chat-header text-xs opacity-50 mb-1';
    headerDiv.innerHTML = `AI Assistant <time class="text-xs opacity-50 ml-2">${new Date().toLocaleTimeString()}</time>`;
    messageDiv.appendChild(headerDiv);
    
    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = 'chat-bubble bg-gray-100 text-gray-800 max-w-2xl';
    bubbleDiv.textContent = ''; // Start empty
    
    // Add cursor effect
    const cursorSpan = document.createElement('span');
    cursorSpan.className = 'animate-pulse';
    cursorSpan.textContent = '▋';
    bubbleDiv.appendChild(cursorSpan);
    
    messageDiv.appendChild(bubbleDiv);
    messagesContainer.appendChild(messageDiv);
    
    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function updateStreamingMessage(messageId, content) {
    const messageElement = document.getElementById(messageId);
    if (!messageElement) return;
    
    const bubbleDiv = messageElement.querySelector('.chat-bubble');
    if (!bubbleDiv) return;
    
    // Apply basic formatting for better streaming appearance
    const formattedContent = applyBasicFormatting(content);
    
    // Update content with basic formatting and preserve cursor
    const cursorSpan = bubbleDiv.querySelector('.animate-pulse');
    bubbleDiv.innerHTML = formattedContent;
    
    // Re-add cursor
    if (cursorSpan) {
        bubbleDiv.appendChild(cursorSpan);
    }
    
    // Scroll to bottom
    const messagesContainer = document.getElementById('chatMessages');
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function removeStreamingMessage(messageId) {
    const messageElement = document.getElementById(messageId);
    if (messageElement) {
        messageElement.remove();
    }
}

function finalizeStreamingMessage(messageId, content) {
    const messageElement = document.getElementById(messageId);
    if (!messageElement) return;
    
    const bubbleDiv = messageElement.querySelector('.chat-bubble');
    if (!bubbleDiv) return;
    
    // Remove cursor and render markdown
    if (content && typeof marked !== 'undefined') {
        bubbleDiv.innerHTML = marked.parse(content);
    } else {
        // Fallback: remove cursor and keep text content
        const cursorSpan = bubbleDiv.querySelector('.animate-pulse');
        if (cursorSpan) {
            cursorSpan.remove();
        }
    }
    
    // Remove the ID so it becomes a regular message
    messageElement.removeAttribute('id');
}
</script>